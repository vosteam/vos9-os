# VOS9-DOS - Руководство разработчика

## Обзор архитектуры

VOS9-DOS построена по модульному принципу, где каждый компонент имеет четко определенную ответственность.

## Структура проекта

```
/root/myos/
├── src/                    # Исходный код
│   ├── boot/              # Загрузчики
│   │   ├── boot.asm       # BIOS загрузчик
│   │   ├── kernel_entry.asm # Точка входа ядра
│   │   └── multiboot.asm  # Multiboot заголовок
│   ├── kernel/            # Ядро системы
│   │   ├── kernel.c       # Основное ядро
│   │   ├── linker.ld      # Скрипт компоновщика
│   │   └── multiboot.ld   # Multiboot линкер
│   ├── drivers/           # Драйверы устройств
│   │   ├── vga.c         # VGA драйвер
│   │   ├── keyboard.c    # Драйвер клавиатуры
│   │   └── timer.c       # Драйвер таймера
│   ├── lib/              # Библиотечные функции
│   │   └── string.c      # Строковые функции
│   ├── shell.c           # Командная оболочка
│   ├── memory.c          # Управление памятью
│   └── filesystem.c      # Файловая система
├── include/               # Заголовочные файлы
├── build/                # Сборочные файлы
├── iso/                  # ISO структура
└── docs/                 # Документация
```

## Компоненты системы

### Ядро (kernel.c)

**Функция**: `kernel_main()`
- Инициализация всех подсистем
- Настройка VGA, клавиатуры, памяти
- Запуск командной оболочки

```c
void kernel_main(uint32_t magic, struct multiboot_info* mbi) {
    // Инициализация драйверов
    vga_init();
    keyboard_init();
    memory_init();
    timer_init(1000);
    filesystem_init();
    
    // Отображение загрузочных сообщений
    // Запуск основного цикла
}
```

### VGA Драйвер (vga.c)

**Основные функции**:
- `vga_init()` - Инициализация VGA
- `vga_putchar()` - Вывод символа
- `vga_puts()` - Вывод строки
- `vga_clear()` - Очистка экрана
- `vga_set_color()` - Установка цвета

```c
// Пример использования
vga_set_color(VGA_COLOR_WHITE, VGA_COLOR_BLACK);
vga_puts("Привет, мир!");
```

### Драйвер клавиатуры (keyboard.c)

**Основные функции**:
- `keyboard_init()` - Инициализация клавиатуры
- `keyboard_get_event()` - Получение события клавиатуры
- Обработка сканкодов
- Преобразование в ASCII

```c
key_event_t event = keyboard_get_event();
if (event.type == KEY_EVENT_PRESS && !event.special) {
    char c = event.ascii;
    // Обработка символа
}
```

### Командная оболочка (shell.c)

**Архитектура**:
- Таблица команд
- Парсер аргументов
- Исполнитель команд

```c
// Структура команды
typedef struct {
    const char* name;
    const char* description;
    void (*function)(int argc, char* argv[]);
} shell_command_t;
```

**Добавление новой команды**:
1. Объявить функцию команды
2. Добавить в таблицу команд
3. Реализовать функцию

```c
void cmd_новая_команда(int argc, char* argv[]) {
    // Реализация команды
}

// В таблице команд:
{"НОВАЯ", "Описание команды", cmd_новая_команда},
```

### Управление памятью (memory.c)

**Функции**:
- `memory_init()` - Инициализация кучи
- `kmalloc()` - Выделение памяти
- `kfree()` - Освобождение памяти

### Файловая система (filesystem.c)

**Базовые операции**:
- `fs_open_file()` - Открытие файла
- `fs_read_file()` - Чтение файла
- `fs_write_file()` - Запись файла
- `fs_delete_file()` - Удаление файла

## Процесс сборки

### Makefile цели

```bash
make           # Полная сборка
make iso       # Создание ISO
make clean     # Очистка
make run       # Запуск в QEMU
make run-iso   # Запуск ISO в QEMU
```

### Компиляция

```bash
# Компиляция ядра
gcc -m32 -nostdlib -nostdinc -fno-builtin -fno-stack-protector \
    -nostartfiles -nodefaultlibs -Wall -Wextra -c -Iinclude \
    src/kernel/kernel.c -o build/kernel.o

# Линковка
ld -m elf_i386 -T src/kernel/linker.ld \
   build/kernel_entry.o build/kernel.o [...] -o build/kernel.bin
```

## Отладка

### QEMU отладка
```bash
# Запуск с отладкой
qemu-system-i386 -cdrom build/vos9.iso -s -S

# В другом терминале
gdb
(gdb) target remote localhost:1234
(gdb) continue
```

### Логирование
В VGA драйвере можно добавить отладочный вывод:
```c
vga_puts("DEBUG: Значение переменной = ");
vga_put_dec(значение);
vga_puts("\n");
```

## Добавление новых функций

### Новый драйвер
1. Создать файл в `src/drivers/`
2. Добавить заголовок в `include/drivers/`
3. Добавить в Makefile
4. Инициализировать в `kernel_main()`

### Новая команда shell
```c
// В shell.c
void cmd_моя_команда(int argc, char* argv[]) {
    if (argc < 2) {
        vga_puts("Использование: МОЯ_КОМАНДА [параметр]\n");
        return;
    }
    
    // Логика команды
    vga_puts("Выполнено!\n");
}

// В таблице команд:
{"МОЯ_КОМАНДА", "Описание моей команды", cmd_моя_команда},
```

## Соглашения по коду

### Стиль кодирования
- Отступы: 4 пробела
- Скобки: K&R стиль
- Имена функций: snake_case
- Константы: UPPER_CASE

### Комментарии
```c
// Краткий комментарий для одной строки

/*
 * Многострочный комментарий
 * для сложных объяснений
 */
```

### Обработка ошибок
```c
if (error_condition) {
    vga_puts("Error: описание ошибки\n");
    return ERROR_CODE;
}
```

## Ограничения разработки

### Технические ограничения
- Только 32-битная архитектура
- Нет стандартной библиотеки C
- Ограниченные системные вызовы
- Простая модель памяти

### Рекомендации
- Минимизируйте использование памяти
- Избегайте сложных алгоритмов
- Тестируйте в эмуляторе
- Документируйте изменения

## Тестирование

### Автоматическое тестирование
```bash
# Создание тестового скрипта
#!/bin/bash
make clean
make iso
if [ $? -eq 0 ]; then
    echo "Сборка успешна"
    # Дополнительные тесты
fi
```

### Ручное тестирование
1. Загрузка системы
2. Проверка всех команд
3. Тестирование граничных случаев
4. Проверка обработки ошибок

## Участие в разработке

### Процесс разработки
1. Клонирование репозитория
2. Создание ветки для функции
3. Разработка и тестирование
4. Документирование изменений
5. Отправка pull request

### Требования к коммитам
- Понятные сообщения коммитов
- Один логический блок на коммит
- Тестирование перед коммитом

---

*VOS9-DOS разработана с любовью к простоте и эффективности*
